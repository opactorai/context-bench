{
  "scenario": "openai-agents:handoffs-guardrails",
  "mode": "oneshot",
  "timestamp": "2025-11-06T16:32:37.943Z",
  "models": [
    {
      "model": "openai/gpt-5",
      "completeness": false,
      "relevance": true,
      "overall_score": 3,
      "confidence": "medium",
      "reasoning": "Step 1: User requirements\n- Use the OpenAI Agents Python SDK\n- Implement routing (handoffs) to specialists\n  - If math calculation → hand off to Calculator\n  - If prose → hand off to Writer\n- Add guardrails to refuse if the user tries to share a credit card number\n- Return a short final answer (non-verbose)\n- Test with input: “write a 1-sentence pep talk”\n\nStep 2: Oracle implementation (inferred)\n- Define two specialist agents (Calculator, Writer) and a routing (triage) agent that uses handoffs to delegate.\n- Implement a guardrail to detect potential credit card numbers and short-circuit with a refusal message.\n- Execute one-turn run, return a short final answer (not a streamed partial output).\n\nAPIs used (from context examples):\n- agents.Agent(name, instructions, handoffs=[...])  [routing]\n- agents.Agent(name, instructions, output_type=..., model=\"...\")  [guardrail]\n- agents.Runner.run_streamed(agent, input=...) with async iteration over result.stream_events()\n- agents.Runner.run(agent, text) and result.final_output_as(PydanticModel)\n- Event types: ResponseTextDeltaEvent, ResponseContentPartDoneEvent, RawResponsesStreamEvent\n- Message item typing: TResponseInputItem (list of {role, content}) and result.to_input_list(); result.current_agent\n\nStep 3: MCP context coverage vs requirements\n1) Routing with handoffs (math→Calculator, prose→Writer)\n- API/function names: PRESENT. Example: triage_agent = Agent(..., handoffs=[french_agent, spanish_agent, english_agent]) in examples/agent_patterns/routing.py.\n- Parameter types/names: PRESENT. Agent(name, instructions, handoffs=list[Agent]). Inputs as list[TResponseInputItem] (dicts: {\"content\": str, \"role\": \"user\"}).\n- Return values/usage: PARTIAL. Streaming example shows how to consume events via Runner.run_streamed(...) and stream_events(); result.to_input_list(), result.current_agent.\n- Usage patterns: PRESENT. The example shows end-to-end routing behavior and handoff-driven streaming output.\n- Gaps: No direct example of creating a \"Calculator\" specialist (tooling or math-specific agent). It’s possible to make a Writer/Calculator via instructions, but how a math computation should be reliably performed (LLM vs tools) is not specified. Still, handoffs mechanism is clear.\n\n2) Guardrails to refuse credit card number sharing\n- API/function names: PRESENT for a guardrail pattern. Example: examples/agent_patterns/streaming_guardrails.py defines a guardrail agent with Pydantic output_type and uses Runner.run(...) then result.final_output_as(...).\n- Parameters: PRESENT. GuardrailOutput schema and guardrail_agent with output_type show how to return booleans and reasoning.\n- Return values: PRESENT. final_output_as(PydanticModel) returns typed output with fields used for decision.\n- Usage patterns: PRESENT but oriented to output streaming checks every N tokens; however, the pattern clearly demonstrates running a guardrail agent on arbitrary text, which can be adapted to input pre-check.\n- Gaps: No explicit example for detecting credit card numbers; developer must craft instructions and schema (e.g., has_credit_card: bool). This is inferable but requires prompt design. No built-in credit-card detector is shown.\n\n3) Return a short final answer (non-streamed)\n- APIs: PARTIAL. The routing example demonstrates streaming via ResponseTextDeltaEvent and printing deltas. It does not demonstrate collecting final text (though it’s straightforward to buffer deltas) nor a non-streamed synchronous call that returns raw text for a non-typed agent.\n- There is an example of non-streamed run for the guardrail agent with final_output_as(...), but not for retrieving plain text from a standard agent. You’d likely implement buffering of deltas until a ResponseContentPartDoneEvent, which is implied but not explicitly shown as a final-text retrieval pattern.\n\n4) Error handling\n- NOT PRESENT. The examples don’t show how errors are surfaced (exceptions, error events) or recommended handling. No retries, timeouts, or error event types are documented in the retrieved context.\n\nStep 4: Decision\n- Completeness: False. While routing via handoffs and a guardrail pattern are demonstrated, critical pieces are missing to fully and confidently implement the oracle: no explicit guidance on error handling; no explicit pattern for obtaining a final non-streamed text output from a standard agent (other than streaming deltas and inferring buffering logic); no concrete credit card detection example (must be invented via prompts). These gaps require guessing beyond the provided context.\n\nEvidence quotes:\n- Handoffs: \"triage_agent = Agent( name=\"triage_agent\", instructions=\"Handoff to the appropriate agent based on the language of the request.\", handoffs=[french_agent, spanish_agent, english_agent], )\" (examples/agent_patterns/routing.py)\n- Streaming usage: \"result = Runner.run_streamed(agent, input=inputs) ... async for event in result.stream_events(): ... if isinstance(data, ResponseTextDeltaEvent): print(data.delta, end=\"\", flush=True) ... elif isinstance(data, ResponseContentPartDoneEvent): print(\"\\n\")\" (routing.py)\n- Guardrails pattern: GuardrailOutput Pydantic model and guardrail_agent with output_type; \"result = await Runner.run(guardrail_agent, text) return result.final_output_as(GuardrailOutput)\" (examples/agent_patterns/streaming_guardrails.py)\n\nRelevance: True. The provided examples directly cover routing/handoffs and a guardrails pattern with the OpenAI Agents SDK, which are central to the requested functionality.\n"
    },
    {
      "model": "deepseek/deepseek-v3.2-exp",
      "completeness": false,
      "relevance": true,
      "overall_score": 2,
      "confidence": "high",
      "reasoning": "Step 1: User Requirements Analysis - The user requires: (1) A routing agent using OpenAI Agents SDK with handoffs, (2) Route to Calculator for math calculations, (3) Route to Writer for prose, (4) Guardrail to refuse credit card numbers, (5) Return short final answer, (6) Test with 'write a 1-sentence pep talk'. Step 2: Oracle Implementation Needs - Would need Agent creation with handoffs parameter, guardrail implementation for credit card detection, routing logic. Step 3: MCP Context Evaluation - Context shows routing.py with handoffs pattern using 'handoffs=[french_agent, spanish_agent, english_agent]' parameter, showing basic routing structure. Context shows streaming_guardrails.py with guardrail pattern using Pydantic models for output validation. However, critical gaps exist: (1) No information on how to detect math vs prose content for routing decisions, (2) No examples of credit card detection guardrails, (3) No Calculator or Writer agent examples to hand off to, (4) Missing details on how to implement the specific routing logic required. While the context demonstrates the existence of handoffs and guardrails features, it lacks the specific implementation details needed to create the requested routing agent with credit card guardrails. Step 4: Decision - INCOMPLETE because multiple critical user requirements (math/prose detection, credit card refusal) cannot be implemented based on the provided context alone."
    },
    {
      "model": "x-ai/grok-4",
      "completeness": true,
      "relevance": true,
      "overall_score": 5,
      "confidence": "high",
      "reasoning": "### Step 1: Analyze User Requirements\nThe user's query requests the following functionality:\n- Create a routing agent using the OpenAI Agents Python SDK.\n- Implement handoffs: Route requests to specialists based on type (math calculation -> Calculator agent; prose -> Writer agent).\n- Implement guardrails: Refuse if the user tries to share a credit card number.\n- Return a short final answer.\n- Test with the input: 'write a 1-sentence pep talk'.\nExplicit constraints: Must use OpenAI Agents Python SDK specifically with handoffs and guardrails features. No specific models or versions mentioned beyond the SDK.\n\n### Step 2: Analyze Oracle Implementation\nThe oracle code (inferred as the ideal implementation matching the query) would likely:\n- Import from 'agents' module: Agent, Runner, and possibly ResponseTextDeltaEvent, ResponseContentPartDoneEvent.\n- Define specialist agents: Calculator (with instructions for math) and Writer (with instructions for prose).\n- Define a routing agent: Agent with name, instructions for routing, and handoffs=[Calculator, Writer].\n- Implement guardrail: A separate guardrail agent (using Agent with output_type like a Pydantic BaseModel) to analyze input text for credit card patterns (e.g., via LLM reasoning or regex, returning a boolean decision).\n- Use Runner.run_streamed or Runner.run to execute the routing agent, handle streaming events, and check guardrail (e.g., on input before routing or during processing).\n- Ensure short final answer via agent instructions.\n- Parameters: Agent(name=str, instructions=str, handoffs=list[Agent], output_type=BaseModel, model=str); Runner.run_streamed(agent=Agent, input=list[dict] or str).\n- Return types: Result object with stream_events() (yielding events like ResponseTextDeltaEvent), to_input_list(), current_agent.\n- Error handling: Async tasks for guardrail checks, checking done() and result() to break if guardrail fails.\n\n### Step 3: Evaluate MCP Context Coverage\nThe MCP context provides two relevant code examples from openai-agents package (version 0.4.2).\n\n- **Requirement: Create routing agent with handoffs (route math to Calculator, prose to Writer)**\n  - Context (Result 2: routing.py): Shows exact pattern - Define agents (e.g., french_agent = Agent(name='french_agent', instructions='You only speak French')), routing agent (triage_agent = Agent(name='triage_agent', instructions='Handoff to the appropriate agent based on the language of the request.', handoffs=[french_agent, spanish_agent, english_agent])). Infer: API=Agent (params: name=str, instructions=str, handoffs=list[Agent]); Usage: Runner.run_streamed(agent, input=inputs), async for event in result.stream_events(), handle ResponseTextDeltaEvent for output. Return: result with to_input_list(), current_agent. Can infer how to define Calculator/Writer similarly and route based on content (adapt instructions).\n  - All checklist items inferable: API names, param types (from usage), purposes (e.g., handoffs enables routing), returns (event.data.delta=str), usage (full async main() example), error handling (implicit in stream loop).\n\n- **Requirement: Implement guardrails (refuse credit card sharing)**\n  - Context (Result 1: streaming_guardrails.py): Shows guardrail pattern - Define guardrail_agent = Agent(name='Checker', instructions=..., output_type=GuardrailOutput (Pydantic BaseModel with reasoning=str, is_readable_by_ten_year_old=bool), model='gpt-4o-mini'). Async function check_guardrail(text=str) -> GuardrailOutput using Runner.run(guardrail_agent, text). Checks during streaming (if guardrail_task.done() and not result.is_readable...). Infer: Adapt to check input for credit card (e.g., change instructions to detect credit card, return bool; run on user input before routing).\n  - All checklist items inferable: API=Agent with output_type, Runner.run; param types (text=str), purposes (analyze text and decide), returns (structured BaseModel), usage (asyncio.create_task, check done()), error handling (break if guardrail fails).\n\n- **Requirement: Return short final answer and test with specific input**\n  - Context: Routing.py shows handling user input in loop, printing deltas for short responses. Guardrails.py shows streaming with early termination. Infer: Add instructions to routing agent for short answers; test by running with input like in main() examples.\n  - All checklist items inferable via combined examples.\n\n- **Explicit constraint: Use OpenAI Agents Python SDK with handoffs/guardrails**\n  - Directly met: Examples are from openai-agents, show handoffs list and guardrail agent patterns.\n\nNo guessing required - examples provide full signatures, usage, and adaptable patterns. Credit card detection logic (e.g., regex or LLM) is application-level, not SDK; context enables SDK integration.\n\n### Step 4: Make Your Decision\nCompleteness = true: ALL requirements addressable; ALL checklist items (API names, param types/names/purposes, returns, usage, error handling) inferable from examples without guessing. Can combine routing.py (for handoffs) and streaming_guardrails.py (for guardrails) to implement equivalent functionality (e.g., check input guardrail before routing, hand off based on content). Relevance = true: Context directly covers routing/handoffs and guardrails in the specified SDK. Overall score=5: Excellent coverage, confident implementation possible. Confidence=high: Clear, comprehensive examples with no ambiguity."
    }
  ],
  "aggregated": {
    "completeness_rate": 0.3333333333333333,
    "relevance_rate": 1,
    "average_score": 3.3333333333333335,
    "final_score": 3,
    "completeness_majority": false,
    "relevance_majority": true,
    "pass": false
  },
  "consensus": false
}
